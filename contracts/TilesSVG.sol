// SPDX-License-Identifier: MIT
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@jbox/sol/contracts/abstract/JuiceboxProject.sol";
import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";

pragma solidity 0.8.6;

contract TilesSvg {
    string[] svgs = [
        '<path d="M100 100L100 0H0C0 55.2285 44.7715 100 100 100Z" fill="#000"/>',
        '<path d="M0 100L0 0H100C100 55.2285 55.2285 100 0 100Z" fill="#000"/>',
        '<path d="M0 0L0 100H100C100 44.7715 55.2285 0 0 0Z" fill="#000"/>',
        '<path d="M100 0L100 100H0C0 44.7715 44.7715 0 100 0Z" fill="#000"/>',
        '<circle cx="50" cy="50" r="50" fill="#000" transform="matrix(1,0,0,1,0,0)" />',
        '<circle cx="20" cy="20" r="20" fill="#000" transform="matrix(1,0,0,1,30,30)" />',
        '<path d="M0 0C0 55.2285 44.7715 100 100 100C100 44.7715 55.2285 0 0 0Z" fill="#000"/>',
        '<path d="M0 100C0 44.7715 44.7715 0 100 0C100 55.2285 55.2285 100 0 100Z" fill="#000"/>',
        '<path d="M100 0H0L100 100V0Z" fill="#000"/>',
        '<path d="M0 0H100L0 100V0Z" fill="#000"/>',
        '<path d="M0 100H100L0 0V100Z" fill="#000"/>',
        '<path d="M100 100H0L100 0V100Z" fill="#000"/>',
        '<path d="M50 100C50 72.3858 27.6142 50 0 50V100H50Z" fill="#000"/>',
        '<path d="M50 100C50 72.3858 72.3858 50 100 50V100H50Z" fill="#000"/>',
        '<path d="M50 0C50 27.6142 72.3858 50 100 50V0H50Z" fill="#000"/>',
        '<path d="M50 0C50 27.6142 27.6142 50 0 50V0H50Z" fill="#000"/>'
    ];

    string canvasColor = "#faf3e8";
    string head =
        string(
            abi.encodePacked(
                '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev/svgjs" version="1.1" width="360" height="360" id="SvgjsSvg1000"><rect width="360" height="360" fill="',
                canvasColor,
                '" /><g transform="matrix(1,0,0,1,30,30)"><g>'
            )
        );
    string foot = "</g></g></svg>";
    uint16 sectorSize = 100;

    uint8[] private positionIndex = [
        0,
        0,
        0,
        1,
        1,
        1,
        2,
        2,
        2,
        3,
        3,
        3,
        4,
        4,
        4,
        5,
        5,
        5,
        6,
        6,
        6,
        7,
        7,
        7,
        8,
        8,
        8,
        9,
        9,
        9,
        10,
        10,
        10,
        11,
        11,
        11,
        12,
        12,
        12,
        13,
        13,
        13,
        14,
        14,
        14,
        15,
        15,
        15,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        6,
        6,
        6,
        6,
        7,
        7,
        7,
        7,
        8,
        8,
        8,
        8,
        9,
        9,
        9,
        9,
        10,
        10,
        10,
        10,
        11,
        11,
        11,
        11,
        12,
        12,
        12,
        12,
        13,
        13,
        13,
        13,
        14,
        14,
        14,
        14,
        15,
        15,
        15,
        15,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13,
        14,
        14,
        15,
        15,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        6,
        6,
        6,
        6,
        7,
        7,
        7,
        7,
        8,
        8,
        8,
        8,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        5,
        5,
        6,
        6,
        6,
        6,
        6,
        6,
        7,
        7,
        7,
        7,
        7,
        7,
        8,
        8,
        8,
        8,
        8,
        8,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        4,
        4
    ];
    uint8[] private size = [
        1,
        2,
        3,
        1,
        2,
        3,
        1,
        2,
        3,
        1,
        2,
        3,
        1,
        2,
        3,
        1,
        2,
        3,
        1,
        2,
        3,
        1,
        2,
        3,
        1,
        2,
        3,
        1,
        2,
        3,
        1,
        2,
        3,
        1,
        2,
        3,
        1,
        2,
        3,
        1,
        2,
        3,
        1,
        2,
        3,
        1,
        2,
        3,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        1,
        1,
        2,
        2,
        0,
        0,
        0,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        2
    ];
    uint8[] private layer = [
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        0
    ];
    bool[] private positionKind = [
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true
    ];
    bool[] private solid = [
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        false
    ];

    struct Ring {
        uint8 positionIndex;
        uint8 size;
        uint8 layer;
        bool positionKind;
        bool solid;
    }

    string private red = "#FE4465";
    string private black = "#222";
    string private blue = "#1A49EF";
    string private yellow = "#F8D938";

    string[][] private sectorColorVariants = [
        [red, yellow, black],
        [red, black, blue],
        [red, yellow, blue],
        [red, blue, yellow],
        [blue, yellow, red],
        [blue, red, yellow],
        [blue, yellow, yellow],
        [blue, black, red],
        [black, red, yellow],
        [black, red, blue],
        [black, blue, red],
        [black, yellow, blue],
        [yellow, red, black],
        [yellow, blue, red],
        [yellow, black, blue],
        [yellow, black, red]
    ];

    function bytesToChars(address _address)
        private
        pure
        returns (uint16[] memory)
    {
        uint16[] memory chars = new uint16[](40);
        uint160 temp = uint160(_address);
        uint32 i = 0;
        while (temp > 0) {
            uint16 right_most_digit = uint16(temp % 16);
            temp -= right_most_digit;
            temp /= 16;
            chars[39 - i] = right_most_digit;
            i++;
        }
        return chars;
    }

    function sectorColorsFromInt16(uint16 char, uint8 r)
        private
        view
        returns (string memory)
    {
        string[] memory colors = sectorColorVariants[char];
        return colors[r];
    }

    function generateTileSectors(
        uint16[4][10] memory chars,
        uint8 i,
        uint8 r
    ) private view returns (string memory, string memory) {
        string memory color = sectorColorsFromInt16(chars[i + 1][0], r);
        return (svgs[chars[i + 1][r + 1]], color);
    }

    // 0x458e5eBAe41DaEEd84A19893e71892F491515f83
    function tokenUri(address addr) public view returns (string memory) {
        string memory str = head;

        /////////////////////////////////////
        uint16[4][10] memory addressSegments;
        uint16[] memory chars = bytesToChars(addr);

        for (uint16 i = 0; i < 10; i++) {
            addressSegments[i][0] = chars[i * 4 + 0];
            addressSegments[i][1] = chars[i * 4 + 1];
            addressSegments[i][2] = chars[i * 4 + 2];
            addressSegments[i][3] = chars[i * 4 + 3];
        }

        ////////////////////////////////////
        Ring[] memory rings = new Ring[](2);
        uint160[2] memory indexes = [
            (uint160(addr) / (16**38)) % 16**2,
            (uint160(addr) / (16**36)) % 16**2
        ];
        uint8 ringsCount = 0;
        for (uint256 i = 0; i < 2; i++) {
            if (indexes[i] == 0) continue;
            uint160 ringIndex = indexes[i] > 0 ? indexes[i] - 1 : indexes[i];
            rings[ringsCount].positionIndex = positionIndex[ringIndex];
            rings[ringsCount].size = size[ringIndex];
            rings[ringsCount].layer = layer[ringIndex];
            rings[ringsCount].positionKind = positionKind[ringIndex];
            rings[ringsCount].solid = solid[ringIndex];
            ringsCount += 1;
        }
        /////////////////////////////////////
        for (uint8 r = 0; r < 3; r++) {
            for (uint8 i = 0; i < 9; i++) {
                (string memory svg, string memory color) = generateTileSectors(
                    addressSegments,
                    i,
                    r
                );

                if (stringStartsWith(svg, "<path")) {
                    str = string(
                        abi.encodePacked(
                            str,
                            '<g transform="matrix(1,0,0,1,',
                            Strings.toString((i % 3) * 100),
                            ",",
                            Strings.toString(((i % 9) / 3) * 100),
                            ')">',
                            replace(
                                replace(svg, "#000", color),
                                "/>",
                                ' style="opacity: 0.88;" />'
                            ),
                            "</g>"
                        )
                    );
                } else if (stringStartsWith(svg, "<circle")) {
                    str = string(
                        abi.encodePacked(
                            str,
                            '<g transform="matrix(1,0,0,1,',
                            Strings.toString((i % 3) * 100),
                            ",",
                            Strings.toString(((i % 9) / 3) * 100),
                            ')">',
                            replace(
                                replace(svg, "#000", color),
                                "/>",
                                ' style="opacity: 0.88;" />'
                            ),
                            "</g>"
                        )
                    );
                }
            }
            for (uint8 i = 0; i < ringsCount; i++) {
                Ring memory ring = rings[i];
                if (ring.layer != r) {
                    continue;
                }
                uint32 i;
                uint32 posX;
                uint32 posY;
                uint32 diameter10x;

                if (ring.size == 0) {
                    diameter10x = 100;
                } else if (ring.size == 1) {
                    diameter10x = 488;
                } else if (ring.size == 2) {
                    diameter10x = 900;
                } else if (ring.size == 3) {
                    diameter10x = 1900;
                }
                if (2 == ring.layer) {
                    diameter10x += 5;
                }
                uint32 posI = uint32(ring.positionIndex);
                if (!ring.positionKind) {
                    posX = (posI % 4) * 100;
                    posY = posI > 11 ? 300 : posI > 7 ? 200 : posI > 3
                        ? 100
                        : 0;
                } else if (ring.positionKind) {
                    posX = 100 * (posI % 3) + 50;
                    posY = (posI > 5 ? 2 * 100 : posI > 2 ? 100 : 0) + 50;
                }
                str = string(
                    abi.encodePacked(
                        str,
                        '<g transform="matrix(1,0,0,1,',
                        Strings.toString(posX),
                        ",",
                        Strings.toString(posY),
                        ')"><circle r="',
                        divide(diameter10x, 20, 5),
                        '" fill="',
                        ring.solid ? canvasColor : "none",
                        '" stroke-width="10" stroke="',
                        canvasColor,
                        '" /></g>'
                    )
                );
            }
        }

        return string(abi.encodePacked(str, foot));
    }

    function replace(
        string memory _str,
        string memory _from,
        string memory _to
    ) private pure returns (string memory) {
        bytes memory _strBytes = abi.encodePacked(_str);
        bytes memory _fromBytes = abi.encodePacked(_from);
        bytes memory _toBytes = abi.encodePacked(_to);
        uint256 i;
        while (i <= _strBytes.length - _fromBytes.length) {
            for (uint256 j = 0; j < _fromBytes.length; j++) {
                if (_strBytes[i + j] != _fromBytes[j]) {
                    break;
                }
                if (j == _fromBytes.length - 1) {
                    bytes memory _newStrBytes = new bytes(
                        _strBytes.length - _fromBytes.length + _toBytes.length
                    );
                    for (uint256 k = 0; k < i; k++) {
                        _newStrBytes[k] = _strBytes[k];
                    }
                    for (uint256 k = 0; k < _toBytes.length; k++) {
                        _newStrBytes[i + k] = _toBytes[k];
                    }
                    for (
                        uint256 k = i + _fromBytes.length;
                        k < _strBytes.length;
                        k++
                    ) {
                        _newStrBytes[
                            k - _fromBytes.length + _toBytes.length
                        ] = _strBytes[k];
                    }
                    return string(_newStrBytes);
                }
            }
            i++;
        }

        return _str;
    }

    function stringStartsWith(string memory _str, string memory _prefix)
        public
        pure
        returns (bool)
    {
        bytes memory _strBytes = bytes(_str);
        bytes memory _prefixBytes = bytes(_prefix);
        bytes memory _tempString = new bytes(_prefixBytes.length);
        for (uint32 i = 0; i < _prefixBytes.length; i++) {
            _tempString[i] = _strBytes[i];
        }
        return
            keccak256(abi.encodePacked(_prefixBytes)) ==
            keccak256(abi.encodePacked(_tempString));
    }

    function divide(
        uint256 _a,
        uint256 _b,
        uint256 n
    ) internal pure returns (string memory) {
        uint256 c = _a / _b;
        uint256 d = (_a * (10**n)) / _b;

        bytes memory _cBytes = abi.encodePacked(
            c > 0 ? Strings.toString(c) : ""
        );
        bytes memory _dBytes = abi.encodePacked(
            d > 0 ? Strings.toString(d) : "0"
        );
        bytes memory _finalBytes = new bytes(_cBytes.length + 1 + n);

        for (uint256 i = 0; i <= _cBytes.length; i++) {
            if (i < _cBytes.length) {
                _finalBytes[i] = _cBytes[i];
            } else if (i == _cBytes.length) {
                _finalBytes[i] = bytes1(uint8(46));
            }
        }

        for (
            uint256 i = 0;
            i < (_dBytes.length > n ? n : _dBytes.length);
            i++
        ) {
            _finalBytes[i + _cBytes.length + 1] = _dBytes[_cBytes.length + i];
        }
        return string(_finalBytes);
    }
}
